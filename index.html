<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Redes - Proyecto Final</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        /* Paleta Olivine */
        :root {
            --olivine-50: #F6FAF3;
            --olivine-100: #EBF4E4;
            --olivine-200: #D3E8CA;
            --olivine-300: #B0D4A1;
            --olivine-400: #90BF7D;
            --olivine-500: #629C4B; 
            --olivine-600: #4E7F3A; 
            --olivine-700: #3F6530;
            --olivine-800: #34512A;
            --olivine-900: #2C4324;
            --olivine-950: #14240F;

            --neutral-text: #1e293b; /* Slate-800 */
            --neutral-label: #334155; /* Slate-700 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--olivine-50); 
            color: var(--neutral-text); 
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .page-title {
            color: var(--olivine-700);
        }
        .page-subtitle {
            color: var(--olivine-600);
            margin-top: 0.5rem; /* Acercar al título principal */
            margin-bottom: 1.5rem; /* Espacio antes del grafo */
        }

        #mynetwork {
            width: 100%;
            max-width: 900px;
            height: 450px; /* Ajustado ligeramente */
            border: 2px solid var(--olivine-200); 
            background-color: #ffffff;
            border-radius: 0.75rem; 
            box-shadow: 0 6px 10px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            margin-bottom: 1.5rem;
            position: relative;
        }
        #mynetwork.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            margin: 0;
            border-radius: 0;
            z-index: 9999;
        }
        .fullscreen-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--olivine-500);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10000;
            transition: background-color 0.2s;
        }
        #download-btn {
            right: 70px;
        }
        .fullscreen-button:hover {
            background: var(--olivine-600);
        }
        .fullscreen-button svg {
            width: 20px;
            height: 20px;
        }
        /* Botón en modo fullscreen */
        #mynetwork.fullscreen ~ #fullscreen-btn {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
        }
         .main-controls-panel, .project-info-panel {
            background-color: #ffffff;
            padding: 0; 
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.06), 0 2px 4px -1px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 900px; 
            margin-bottom: 1.5rem;
        }
        .project-info-panel .panel-content { /* Padding específico para el contenido del panel de info */
             padding: 1.5rem;
        }
         .project-info-panel h3 {
            font-size: 1.25rem; 
            font-weight: 600; 
            color: var(--olivine-600); 
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--olivine-100); 
        }

        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            border-bottom: 2px solid var(--olivine-200);
            background-color: white;
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            overflow: hidden;
        }
        .tab-button {
            flex: 1 1 0;
            text-align: center;
            padding: 1rem 0.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            background: transparent;
            border: none;
            border-radius: 0.75rem 0.75rem 0 0;
            color: var(--olivine-700);
            transition: background 0.18s, color 0.18s, border-bottom 0.18s;
            margin-bottom: -2px;
            cursor: pointer;
        }
        .tab-button.active {
            background: #f6faf3;
            color: var(--olivine-900);
            border-bottom: 4px solid var(--olivine-500);
            z-index: 2;
        }
        .tab-button:not(.active):hover {
            background: var(--olivine-100);
            color: var(--olivine-700);
        }
        .tab-content {
            padding: 1.5rem; 
        }
        .tab-pane {
            display: none; 
        }
        .tab-pane.active {
            display: block; 
        }

        .control-group h4 { 
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--olivine-600);
            margin-top: 1rem;
            margin-bottom: 0.75rem;
        }
         .control-group h3 { /* Para títulos dentro de las pestañas */
            font-size: 1.25rem; 
            font-weight: 600; 
            color: var(--olivine-600); 
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--olivine-100); 
        }
        .control-group hr {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border-color: var(--olivine-100);
        }

        /* Sub-tarjetas/secciones dentro de cada menú */
        .subcard {
            background: var(--olivine-50);
            border: 1px solid var(--olivine-200);
            border-radius: 0.5rem;
            padding: 1.1rem 1.2rem 1.1rem 1.2rem;
            margin-bottom: 1.2rem;
            box-shadow: 0 1px 2px 0 rgba(98,156,75,0.04);
        }
        .subcard:last-child {
            margin-bottom: 0;
        }
        .subcard h4 {
            margin-top: 0;
        }
        .subcard hr {
            margin: 1rem 0;
        }
        /* Layout paralelo para nodos y enlaces en PC */
        .node-section-row, .edge-section-row {
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
        }
        @media (min-width: 900px) {
            .node-section-row, .edge-section-row {
                flex-direction: row;
            }
            .node-section-row .subcard, .edge-section-row .subcard {
                flex: 1 1 0;
                margin-bottom: 0;
            }
        }

        /* Tarjetas principales para nodos y enlaces */
        .main-card {
            background: #fff;
            border-radius: 0.85rem;
            box-shadow: 0 4px 16px 0 rgba(98,156,75,0.08);
            border: 1.5px solid var(--olivine-200);
            margin-bottom: 2rem;
            padding: 1.5rem 1.5rem 1.2rem 1.5rem;
        }
        .main-card h3 {
            color: var(--olivine-700);
            font-size: 1.35rem;
            font-weight: 700;
            margin-bottom: 1.2rem;
        }
        /* Botones modernos y centrados */
        button, input[type="button"] {
            border-radius: 0.5rem;
            padding: 2rem 2.2rem;
            font-weight: 500;
            margin: 0.5rem 0 0.5rem 0;
            display: block;
            width: 100%;
            box-shadow: 0 2px 8px 0 rgba(98,156,75,0.08);
            transition: background 0.18s, color 0.18s, box-shadow 0.18s, transform 0.18s;
        }
        .btn-primary {
            background-color: var(--olivine-500);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--olivine-600);
            box-shadow: 0 4px 16px 0 rgba(98,156,75,0.13);
            transform: translateY(-2px) scale(1.03);
        }
        .btn-danger {
            background-color: #e11d48;
            color: white;
        }
        .btn-danger:hover {
            background-color: #be123c;
            box-shadow: 0 4px 16px 0 rgba(225,29,72,0.13);
            transform: translateY(-2px) scale(1.03);
        }

        #messageBox {
            border-radius: 0.5rem;
            padding: 0.75rem 1.25rem;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
            width: 100%;
            max-width: 900px; 
            text-align: center;
        }
        .message-success { background-color: var(--olivine-100); color: var(--olivine-700); border: 1px solid var(--olivine-300); }
        .message-error { background-color: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; } 
        .message-info { background-color: #e0f2fe; color: #0369a1; border: 1px solid #7dd3fc; } 

        input[type="text"], 
        input[type="number"], 
        select, 
        textarea {
            appearance: none; 
            -webkit-appearance: none;
            -moz-appearance: none;
            border-radius: 0.375rem; 
            padding: 0.625rem 0.875rem; 
            border: 1px solid var(--olivine-300); 
            width: 100%; 
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background-color: var(--olivine-50); 
            color: var(--neutral-text);
            font-size: 0.9rem; 
            line-height: 1.5; 
        }
        input[type="text"]:focus, 
        input[type="number"]:focus, 
        select:focus, 
        textarea:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            border-color: var(--olivine-500); 
            box-shadow: 0 0 0 3px rgba(98, 156, 75, 0.3); 
        }
        label {
            display: block;
            margin-bottom: 0.375rem; 
            font-weight: 500;
            color: var(--neutral-label); 
            font-size: 0.875rem; 
        }
        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%234E7F3A' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E"); 
            background-position: right 0.75rem center; 
            background-repeat: no-repeat;
            background-size: 1.25em 1.25em; 
            padding-right: 2.75rem; 
        }
        ::placeholder { color: var(--olivine-400); opacity: 1; }
        :-ms-input-placeholder { color: var(--olivine-400); }
        ::-ms-input-placeholder { color: var(--olivine-400); }
        textarea { min-height: 120px; }

        .json-example {
            background-color: var(--olivine-100); 
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem; 
            overflow-x: auto; 
            border: 1px solid var(--olivine-200); 
            color: var(--olivine-800);
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* Aspect ratio 16:9 */
            height: 0;
            overflow: hidden;
            border-radius: 0.5rem; /* Bordes redondeados para el contenedor del video */
            margin-top: 1rem;
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none; /* Quitar borde del iframe */
        }
        footer {
            width: 100%;
            text-align: center;
            padding: 1.5rem 0;
            margin-top: 2rem;
            color: var(--olivine-600);
            font-size: 0.875rem;
            border-top: 1px solid var(--olivine-200);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="p-4 md:p-6">

    <h1 class="text-3xl md:text-4xl font-bold text-center page-title">Simulador Avanzado de Topologías de Red</h1>
    <p class="text-xl text-center page-subtitle">Proyecto Final Matemáticas Discretas</p>

    <div style="position: relative; width: 100%; max-width: 900px; margin: 0 auto;">
        <div id="mynetwork" class="mb-6"></div>
        <button id="fullscreen-btn" class="fullscreen-button" onclick="toggleFullscreen()" title="Alternar pantalla completa">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
            </svg>
        </button>
        <button id="download-btn" class="fullscreen-button" style="right: 70px;" onclick="downloadGraphImage()" title="Descargar imagen del grafo">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
            </svg>
        </button>
    </div>
    <div id="messageBox"></div>

    <div class="main-controls-panel">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="tabEdit" onclick="openTab(event, 'tabEdit')">Editar Red</button>
            <button class="tab-button" data-tab="tabSimulate" onclick="openTab(event, 'tabSimulate')">Simular y Analizar</button>
            <button class="tab-button" data-tab="tabData" onclick="openTab(event, 'tabData')">Carga masiva</button>
            <button class="tab-button" data-tab="tabInstructions" onclick="openTab(event, 'tabInstructions')">Instrucciones</button>
        </div>

        <div id="tabEdit" class="tab-pane active">
            <div class="tab-content control-group">
                <div class="main-card">
                    <h3>Gestión de Nodos</h3>
                    <div class="node-section-row">
                        <div class="subcard">
                            <h4>Añadir Nodo</h4>
                            <div class="space-y-3">
                                <div>
                                    <label for="node-id">ID del Nodo:</label>
                                    <input type="text" id="node-id" placeholder="Ej: RouterA, ServidorPrincipal">
                                </div>
                                <button onclick="addNode()" class="btn-primary">Añadir Nodo</button>
                            </div>
                        </div>
                        <div class="subcard">
                            <h4>Eliminar Nodo</h4>
                            <div class="space-y-3">
                                <div>
                                    <label for="node-to-delete">Seleccionar Nodo para Eliminar:</label>
                                    <select id="node-to-delete"><option value="">Seleccionar nodo a eliminar</option></select>
                                </div>
                                <button onclick="deleteNode()" class="btn-danger">Eliminar Nodo</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="main-card">
                    <h3>Gestión de Enlaces</h3>
                    <div class="edge-section-row">
                        <div class="subcard">
                            <h4>Añadir Enlace</h4>
                            <div class="space-y-3">
                                <div>
                                    <label for="edge-from">Desde (Nodo Origen):</label>
                                    <select id="edge-from"><option value="">Seleccionar nodo de origen</option></select>
                                </div>
                                <div>
                                    <label for="edge-to">Hasta (Nodo Destino):</label>
                                    <select id="edge-to"><option value="">Seleccionar nodo de destino</option></select>
                                </div>
                                <div>
                                    <label for="edge-type">Tipo de Enlace:</label>
                                    <select id="edge-type">
                                        <option value="undirected">No dirigido</option>
                                        <option value="directed">Dirigido</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="edge-weight">Peso (Latencia/Costo):</label>
                                    <input type="number" id="edge-weight" placeholder="Ej: 5" min="0">
                                </div>
                                <button onclick="addEdge()" class="btn-primary">Añadir Enlace</button>
                            </div>
                        </div>
                        <div class="subcard">
                            <h4>Eliminar Enlace</h4>
                            <div class="space-y-3 mt-4">
                                <div>
                                    <label for="edge-to-delete">Seleccionar Enlace para Eliminar:</label>
                                    <select id="edge-to-delete"><option value="">Seleccionar enlace a eliminar</option></select>
                                </div>
                                <button onclick="deleteEdge()" class="btn-danger">Eliminar Enlace</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="main-card">
                    <h3>Control General de la Simulación</h3>
                    <div class="subcard">
                        <button onclick="resetGraphVisualization()" class="btn-danger">
                            Reiniciar Simulación Completa
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="tabSimulate" class="tab-pane">
            <div class="tab-content control-group">
                <div class="subcard">
                    <h4>Simulación de Caída de Enlaces</h4>
                    <p class="text-sm mb-4" style="color: var(--olivine-600);">
                        Para simular que un enlace de red (arista) se ha caído o para reactivarlo, simplemente <strong>haga clic sobre la arista</strong> directamente en el grafo.
                    </p>
                </div>
                <div class="subcard">
                    <h4>Análisis de Ruta con Dijkstra</h4>
                    <div class="space-y-3">
                        <div>
                            <label for="start-node">Nodo Origen para Dijkstra:</label>
                            <select id="start-node"><option value="">Seleccionar nodo de origen</option></select>
                        </div>
                        <div>
                            <label for="end-node">Nodo Destino para Dijkstra:</label>
                            <select id="end-node"><option value="">Seleccionar nodo de destino</option></select>
                        </div>
                        <button onclick="runDijkstra()" class="w-full btn-primary">Calcular Ruta Óptima</button>
                        <div id="pathSelectorContainer" class="mt-4 space-y-2" style="display: none;">
                            </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="tabData" class="tab-pane">
            <div class="tab-content control-group">
                <div class="subcard">
                    <h4>Ejemplos de Topologías</h4>
                    <div class="space-y-3">
                        <button id="copy-json-example1" class="btn-primary" onclick="copyJsonExample1()">Copiar Ejemplo 1 - Grafo No Dirigido Simple</button>
                        <button id="copy-json-example2" class="btn-primary" onclick="copyJsonExample2()">Copiar Ejemplo 2 - Red de Computadoras</button>
                    </div>
                </div>
                <div class="subcard">
                    <h4>Cargar Topología desde JSON</h4>
                    <div class="space-y-3">
                        <div>
                            <label for="json-input">Puedes crear cualquier tipo de grafo (dirigido, no dirigido o mixto) usando el siguiente formato JSON. Consulta las instrucciones y copia el ejemplo si lo necesitas.</label>
                            <textarea id="json-input" rows="10" placeholder="Pega aquí tu JSON de grafo..."></textarea>
                        </div>
                        <button onclick="loadGraphFromJson()" class="btn-primary">Cargar Topología JSON</button>
                    </div>
                </div>
                <div class="subcard">
                    <h4>Instrucciones y ejemplo de JSON</h4>
                    <button id="copy-json-instructions" class="btn-primary" style="margin-top: 0.7rem; margin-bottom: 0.7rem;">Copiar instrucciones JSON</button>
                    <div class="json-example" id="json-instructions-block">
                        <pre id="json-example-pre">{
  "nodes": [
    { "id": "A", "label": "Nodo A", "x": 0, "y": 0 },
    { "id": "B", "label": "Nodo B", "x": 150, "y": 100 },
    { "id": "C", "label": "Nodo C" }
  ],
  "edges": [
    { "from": "A", "to": "B", "weight": 3, "directed": false },
    { "from": "B", "to": "C", "weight": 2, "directed": true },
    { "from": "C", "to": "A", "weight": 1 }
  ]
}
</pre>
                    </div>
                    <ul class="list-disc list-inside mt-3 text-sm space-y-1" id="json-instructions-list" style="color: var(--neutral-label);">
                        <li><b>"nodes"</b>: Array de objetos nodo. Cada nodo debe tener al menos <code>id</code> (único). Opcionalmente puede tener <code>label</code> (nombre mostrado), <code>x</code> y <code>y</code> (posición inicial).</li>
                        <li><b>"edges"</b>: Array de objetos enlace. Cada enlace debe tener <code>from</code> (nodo origen), <code>to</code> (nodo destino) y <code>weight</code> (peso/costo).</li>
                        <li>Para un <b>enlace dirigido</b> (flecha de <code>from</code> a <code>to</code>), usa <code>"directed": true</code> o simplemente omite el campo (por defecto es dirigido).</li>
                        <li>Para un <b>enlace no dirigido</b> (sin flecha, conecta ambos nodos en ambos sentidos), usa <code>"directed": false</code>.</li>
                        <li>Puedes mezclar enlaces dirigidos y no dirigidos en el mismo grafo (grafo mixto).</li>
                        <li>No repitas enlaces opuestos para no dirigidos: basta con uno con <code>"directed": false</code>.</li>
                        <li>Ejemplo de grafo mixto: A—B (no dirigido), B→C (dirigido), C→A (dirigido).</li>
                    </ul>
                </div>
            </div>
        </div>

        <div id="tabInstructions" class="tab-pane">
            <div class="tab-content control-group"> <h3>Instrucciones de Uso</h3>
                <p class="text-sm mb-3" style="color: var(--olivine-600);">
                    Esta herramienta permite visualizar topologías de red, calcular la ruta óptima y simular la caída/reactivación de enlaces.
                </p>
                <h4 class="text-md font-semibold mt-3 mb-1" style="color: var(--olivine-700);">Funcionalidades Principales:</h4>
                 <ul class="list-disc list-inside text-sm space-y-1 mb-3" style="color: var(--neutral-label);">
                    <li><strong>Editar Red:</strong> Añada o elimine nodos y enlaces (con sus pesos).</li>
                    <li><strong>Simular y Analizar:</strong>
                        <ul>
                            <li>Haga clic en un enlace en el grafo para activarlo/desactivarlo.</li>
                            <li>Calcule la(s) ruta(s) más corta(s) usando Dijkstra. Si hay múltiples rutas de igual costo, se le informará, podrá seleccionar cuál visualizar, y todas se mostrarán en la consola del desarrollador (F12).</li>
                        </ul>
                    </li>
                    <li><strong>Datos y Control:</strong> Cargue una topología desde JSON o reinicie la simulación.</li>
                </ul>

                <h4 class="text-md font-semibold mt-4 mb-1" style="color: var(--olivine-700);">Carga Masiva con JSON:</h4>
                <p class="text-sm mb-2" style="color: var(--neutral-label);">
                    Puedes crear cualquier tipo de grafo (dirigido, no dirigido o mixto) usando el siguiente formato JSON. <br>
                    <button id="copy-json-instructions" class="btn-primary" style="margin-top: 0.7rem; margin-bottom: 0.7rem;">Copiar instrucciones JSON</button>
                </p>
                <div class="json-example" id="json-instructions-block">
                    <pre id="json-example-pre">{
  "nodes": [
    { "id": "A", "label": "Nodo A", "x": 0, "y": 0 },
    { "id": "B", "label": "Nodo B", "x": 150, "y": 100 },
    { "id": "C", "label": "Nodo C" }
  ],
  "edges": [
    { "from": "A", "to": "B", "weight": 3, "directed": false },
    { "from": "B", "to": "C", "weight": 2, "directed": true },
    { "from": "C", "to": "A", "weight": 1 }
  ]
}
</pre>
                </div>
                <ul class="list-disc list-inside mt-3 text-sm space-y-1" id="json-instructions-list" style="color: var(--neutral-label);">
                    <li><b>"nodes"</b>: Array de objetos nodo. Cada nodo debe tener al menos <code>id</code> (único). Opcionalmente puede tener <code>label</code> (nombre mostrado), <code>x</code> y <code>y</code> (posición inicial).</li>
                    <li><b>"edges"</b>: Array de objetos enlace. Cada enlace debe tener <code>from</code> (nodo origen), <code>to</code> (nodo destino) y <code>weight</code> (peso/costo).</li>
                    <li>Para un <b>enlace dirigido</b> (flecha de <code>from</code> a <code>to</code>), usa <code>"directed": true</code> o simplemente omite el campo (por defecto es dirigido).</li>
                    <li>Para un <b>enlace no dirigido</b> (sin flecha, conecta ambos nodos en ambos sentidos), usa <code>"directed": false</code>.</li>
                    <li>Puedes mezclar enlaces dirigidos y no dirigidos en el mismo grafo (grafo mixto).</li>
                    <li>No repitas enlaces opuestos para no dirigidos: basta con uno con <code>"directed": false</code>.</li>
                    <li>Ejemplo de grafo mixto: A—B (no dirigido), B→C (dirigido), C→A (dirigido).</li>
                </ul>
                <script>
                document.addEventListener('DOMContentLoaded', function() {
                  const btn = document.getElementById('copy-json-instructions');
                  const block = document.getElementById('json-instructions-block');
                  const pre = document.getElementById('json-example-pre');
                  const list = document.getElementById('json-instructions-list');
                  if(btn && block && pre && list) {
                    btn.onclick = function() {
                      let text = 'INSTRUCCIONES PARA CREAR GRAFOS EN FORMATO JSON:\n';
                      text += list.innerText + '\n\nEJEMPLO DE JSON:\n';
                      text += pre.innerText || pre.textContent;
                      navigator.clipboard.writeText(text);
                      btn.textContent = '¡Copiado!';
                      setTimeout(()=>{btn.textContent = 'Copiar instrucciones JSON';}, 1800);
                    };
                  }
                });
                </script>
            </div>
        </div>
    </div>
    
    <div class="project-info-panel">
        <div class="panel-content">
            <h3>Sobre este proyecto</h3>
            <p class="text-sm mb-3" style="color: var(--neutral-label);">
                Este simulador de redes es una herramienta interactiva diseñada para visualizar y analizar topologías de red. Permite a los usuarios construir grafos representando nodos (como routers o servidores) y enlaces (conexiones con pesos o costos), y luego aplicar el algoritmo de Dijkstra para encontrar la ruta óptima entre dos puntos seleccionados. 
                Además, ofrece la capacidad de simular escenarios dinámicos, como la caída y reactivación de enlaces, para observar cómo esto afecta las rutas de comunicación. Es una aplicación práctica de conceptos de teoría de grafos y algoritmos fundamentales en matemáticas discretas y ciencias de la computación.
            </p>
            <div class="video-container">
                <iframe src="https://www.youtube.com/embed/GazC3A4OQTE" 
                        title="YouTube video player" 
                        frameborder="0" 
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                        referrerpolicy="strict-origin-when-cross-origin" 
                        allowfullscreen>
                </iframe>
            </div>
        </div>
    </div>

    <footer>
        Desarrollado por Esteban Infante, Joer Durán y José Miguel Riveros.
    </footer>

    <script type="text/javascript">
        // Paleta Olivine aplicada
        const OLIVINE_DEFAULT_EDGE_COLOR = '#629C4B'; 
        const OLIVINE_DEFAULT_EDGE_HIGHLIGHT_COLOR = '#4E7F3A'; 
        const OLIVINE_DEFAULT_EDGE_HOVER_COLOR = '#3F6530'; 
        const OLIVINE_INACTIVE_EDGE_COLOR = '#B0D4A1'; 
        
        const DIJKSTRA_PATH_EDGE_COLOR = '#d946ef'; 
        const DIJKSTRA_PATH_NODE_BORDER_COLOR = '#a21caf'; 
        const DIJKSTRA_PATH_NODE_BG_COLOR = '#f0abfc'; 

        const NODE_BORDER_COLOR = '#4E7F3A'; 
        const NODE_BG_COLOR = '#90BF7D'; 
        const NODE_HIGHLIGHT_BORDER_COLOR = '#3F6530'; 
        const NODE_HIGHLIGHT_BG_COLOR = '#629C4B'; 


        const container = document.getElementById('mynetwork');
        const visNodes = new vis.DataSet([]);
        const visEdges = new vis.DataSet([]);
        const options = {
            layout: { hierarchical: false, improvedLayout: true },
            edges: {
                arrows: { to: { enabled: true, scaleFactor: 0.7 } }, 
                selfReference: { size: 20, angle: Math.PI / 4, renderBehindTheNode: true },
                color: {
                    color: OLIVINE_DEFAULT_EDGE_COLOR, 
                    highlight: OLIVINE_DEFAULT_EDGE_HIGHLIGHT_COLOR, 
                    hover: OLIVINE_DEFAULT_EDGE_HOVER_COLOR
                },
                font: { align: 'top', color: '#3F6530' },
                smooth: { enabled: true, type: "dynamic" },
                width: 2.5, 
            },
            nodes: {
                shape: 'ellipse', 
                size: 22,    
                font: { size: 14, color: '#ffffff', face: 'Inter, sans-serif' },
                color: { 
                    border: NODE_BORDER_COLOR, 
                    background: NODE_BG_COLOR, 
                    highlight: { border: NODE_HIGHLIGHT_BORDER_COLOR, background: NODE_HIGHLIGHT_BG_COLOR }
                },
                borderWidth: 2.5,
            },
            physics: {
                enabled: true,
                solver: 'barnesHut',
                barnesHut: {
                    gravitationalConstant: -2000,
                    centralGravity: 0.3,
                    springLength: 150,
                    springConstant: 0.08,
                    damping: 0.4,
                    avoidOverlap: 0.5
                },
                stabilization: {
                    enabled: true,
                    iterations: 1000,
                    updateInterval: 50,
                    onlyDynamicEdges: false,
                    fit: true
                }
            },
            interaction: { hover: true, tooltipDelay: 150, dragNodes: true, dragView: true, zoomView: true, multiselect: false }
        };
        const network = new vis.Network(container, { nodes: visNodes, edges: visEdges }, options);

        let allCalculatedShortestPaths = [];
        let visuallyHighlightedPathEdges = [];


        const nodeIdInput = document.getElementById('node-id');
        // Añadir nodo al presionar Enter
        nodeIdInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevenir el comportamiento por defecto
                addNode();
            }
        });
        const edgeFromSelect = document.getElementById('edge-from');
        const edgeToSelect = document.getElementById('edge-to');
        const edgeWeightInput = document.getElementById('edge-weight');
        const startNodeSelect = document.getElementById('start-node');
        const endNodeSelect = document.getElementById('end-node');
        const nodeToDeleteSelect = document.getElementById('node-to-delete');
        const edgeToDeleteSelect = document.getElementById('edge-to-delete');
        const messageBox = document.getElementById('messageBox');
        const jsonInput = document.getElementById('json-input');

        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-pane");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove("active");
            }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }
            document.getElementById(tabName).style.display = "block";
            document.getElementById(tabName).classList.add("active");
            if (evt && evt.currentTarget) { 
                evt.currentTarget.classList.add("active");
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const firstTabButton = document.querySelector('.tab-buttons .tab-button');
            if (firstTabButton) {
                 openTab({ currentTarget: firstTabButton }, firstTabButton.dataset.tab);
            }
            updateAllSelectors(); 
            showMessage('Bienvenido al Simulador de Redes. Construya su topología o cárguela desde JSON.', 'info');
        });


        function showMessage(text, type = 'info', duration = 6000) { 
            messageBox.textContent = text;
            messageBox.className = 'mb-6 '; 
            if (type === 'success') messageBox.classList.add('message-success');
            else if (type === 'error') messageBox.classList.add('message-error');
            else messageBox.classList.add('message-info');
            
            setTimeout(() => {
                if (messageBox.textContent === text) { 
                    messageBox.textContent = '';
                    messageBox.className = 'mb-6';
                }
            }, duration); 
        }

        function updateAllSelectors() {
            updateNodeSelectors();
            updateEdgeSelectors();
        }

        function updateNodeSelectors() {
            const nodes = visNodes.get({ fields: ['id', 'label'], order: 'label' });
            const selectors = [edgeFromSelect, edgeToSelect, startNodeSelect, endNodeSelect, nodeToDeleteSelect];
            
            selectors.forEach(sel => {
                const currentValue = sel.value;
                while (sel.options.length > 1) sel.remove(1); 
                nodes.forEach(node => {
                    const option = new Option(node.label || node.id, node.id);
                    sel.add(option);
                });
                if (Array.from(sel.options).some(opt => opt.value === currentValue)) {
                    sel.value = currentValue;
                } else {
                    sel.value = ""; 
                }
            });
        }
        
        function updateEdgeSelectors() {
            const edges = visEdges.get({ fields: ['id', 'from', 'to', 'label', 'value'], order: 'from' });
            const currentValue = edgeToDeleteSelect.value;
            while (edgeToDeleteSelect.options.length > 1) edgeToDeleteSelect.remove(1);

            edges.forEach(edge => {
                const fromNode = visNodes.get(edge.from);
                const toNode = visNodes.get(edge.to);
                const fromLabel = fromNode ? (fromNode.label || fromNode.id) : edge.from;
                const toLabel = toNode ? (toNode.label || toNode.id) : edge.to;
                const edgeDisplayLabel = `${fromLabel} → ${toLabel} (Peso: ${edge.label || edge.value})`;
                const option = new Option(edgeDisplayLabel, edge.id);
                edgeToDeleteSelect.add(option);
            });
             if (Array.from(edgeToDeleteSelect.options).some(opt => opt.value === currentValue)) {
                edgeToDeleteSelect.value = currentValue;
            } else {
                edgeToDeleteSelect.value = "";
            }
        }

        function addNode() {
            const nodeId = nodeIdInput.value.trim();
            if (!nodeId) return showMessage('El ID del nodo no puede estar vacío.', 'error');
            if (visNodes.get(nodeId)) return showMessage(`El nodo "${nodeId}" ya existe.`, 'error');
            
            visNodes.add({ id: nodeId, label: nodeId }); 
            network.fit({animation: {duration: 500, easingFunction: 'easeInOutQuad'}}); 
            nodeIdInput.value = ''; 
            updateAllSelectors();
            showMessage(`Nodo "${nodeId}" añadido.`, 'success');
        }

        function addEdge() {
            const from = edgeFromSelect.value;
            const to = edgeToSelect.value;
            const weight = parseInt(edgeWeightInput.value);
            const edgeType = document.getElementById('edge-type').value;

            if (!from || !to) return showMessage('Seleccione nodo de origen y destino.', 'error');
            if (isNaN(weight) || weight < 0) return showMessage('El peso debe ser un número no negativo.', 'error');

            const existingEdgeSameDirection = visEdges.get({
                filter: item => item.from === from && item.to === to
            });
            if (existingEdgeSameDirection.length > 0) {
                 if (from === to) {
                    return showMessage(`Ya existe un bucle en "${from}". No se permiten múltiples bucles idénticos.`, 'error');
                 } else {
                    return showMessage(`Ya existe un enlace de "${from}" a "${to}".`, 'error');
                 }
            }
            // Para bidireccional, solo una arista con flechas en ambos extremos
            const edgeId = `edge-${from}-${to}-${Date.now()}`; 
            let arrowsOption;
            if (edgeType === 'bidirectional' && from !== to) {
                arrowsOption = { to: { enabled: true, scaleFactor: 0.7 }, from: { enabled: true, scaleFactor: 0.7 } };
            } else if (edgeType === 'directional') {
                arrowsOption = { to: { enabled: true, scaleFactor: 0.7 } };
            } else {
                arrowsOption = { to: { enabled: false } };
            }
            visEdges.add({ 
                id: edgeId, from, to, 
                label: String(weight), value: weight,
                active: true, dashes: false,
                arrows: arrowsOption,
                color: { color: OLIVINE_DEFAULT_EDGE_COLOR, highlight: OLIVINE_DEFAULT_EDGE_HIGHLIGHT_COLOR, hover: OLIVINE_DEFAULT_EDGE_HOVER_COLOR }
            });

            edgeWeightInput.value = ''; 
            updateEdgeSelectors(); 
            if (from === to) {
                showMessage(`Bucle añadido en "${from}" con peso ${weight}.`, 'success');
            } else {
                showMessage(`Enlace ${edgeType === 'bidirectional' ? 'bidireccional' : 'direccional'} de "${from}" a "${to}" (peso ${weight}) añadido.`, 'success');
            }
        }

        function deleteNode() {
            const nodeIdToDelete = nodeToDeleteSelect.value;
            if (!nodeIdToDelete) return showMessage('Seleccione un nodo para eliminar.', 'error');

            const edgesToRemove = visEdges.get({
                filter: edge => edge.from === nodeIdToDelete || edge.to === nodeIdToDelete
            }).map(edge => edge.id);

            if (edgesToRemove.length > 0) visEdges.remove(edgesToRemove);
            visNodes.remove(nodeIdToDelete);
            
            updateAllSelectors();
            showMessage(`Nodo "${nodeIdToDelete}" y sus enlaces han sido eliminados.`, 'success');
            clearDijkstraPathVisuals(); 
        }

        function deleteEdge() {
            const edgeIdToDelete = edgeToDeleteSelect.value;
            if (!edgeIdToDelete) return showMessage('Seleccione un enlace para eliminar.', 'error');
            
            const edge = visEdges.get(edgeIdToDelete);
            visEdges.remove(edgeIdToDelete);
            updateEdgeSelectors();
            showMessage(`Enlace eliminado.`, 'success');
            if (edge && visuallyHighlightedPathEdges.includes(edge.id)) {
                 clearDijkstraPathVisuals(); 
            }
        }
        
        function clearVisualHighlightsOnly() {
            if (visuallyHighlightedPathEdges.length > 0) {
                const updates = [];
                visuallyHighlightedPathEdges.forEach(edgeId => {
                    const edge = visEdges.get(edgeId);
                    if (edge) { 
                        updates.push({ 
                            id: edgeId, 
                            color: edge.active === false ? { color: OLIVINE_INACTIVE_EDGE_COLOR } : { color: OLIVINE_DEFAULT_EDGE_COLOR },
                            width: options.edges.width 
                        });
                    }
                });
                if (updates.length > 0) visEdges.update(updates);
            }
            const allGraphNodes = visNodes.get({ fields: ['id'] });
            const nodeUpdatesDefault = allGraphNodes.map(node => ({
                id: node.id,
                color: { border: NODE_BORDER_COLOR, background: NODE_BG_COLOR }
            }));
            if (nodeUpdatesDefault.length > 0) visNodes.update(nodeUpdatesDefault);
            visuallyHighlightedPathEdges = [];
        }

        function clearDijkstraPathVisuals() {
            clearVisualHighlightsOnly();
            const pathSelectorContainer = document.getElementById('pathSelectorContainer');
            if (pathSelectorContainer) {
                pathSelectorContainer.innerHTML = ''; 
                pathSelectorContainer.style.display = 'none';
            }
            allCalculatedShortestPaths = [];
        }


        function dijkstraAlgorithm(startNodeId) {
            const nodes = visNodes.getIds();
            const allEdgesData = visEdges.get(); 
            const distances = new Map(); 
            const predecessors = new Map(); 
            const pq = new vis.DataSet(); 

            nodes.forEach(node => {
                distances.set(node, Infinity);
                predecessors.set(node, []); 
                pq.add({ id: node, distance: Infinity });
            });

            distances.set(startNodeId, 0);
            pq.update({ id: startNodeId, distance: 0 });

            while (pq.length > 0) {
                const uItem = pq.min('distance');
                if (!uItem || uItem.distance === Infinity) break; 
                const u = uItem.id;
                pq.remove(u);

                const neighbors = allEdgesData.filter(edge => 
                    (edge.from === u || edge.to === u) && edge.active !== false
                );
                
                for (const neighborEdge of neighbors) {
                    const v = neighborEdge.from === u ? neighborEdge.to : neighborEdge.from;
                    const weight = parseInt(neighborEdge.value || neighborEdge.label);
                    if (isNaN(weight)) continue;
                    const alt = distances.get(u) + weight;

                    if (alt < distances.get(v)) {
                        distances.set(v, alt);
                        predecessors.set(v, [{ node: u, edgeId: neighborEdge.id }]); 
                        if (pq.get(v)) pq.update({ id: v, distance: alt });
                    } else if (alt === distances.get(v) && distances.get(v) !== Infinity) {
                        const currentPreds = predecessors.get(v) || [];
                        if (!currentPreds.some(p => p.node === u && p.edgeId === neighborEdge.id)) {
                           currentPreds.push({ node: u, edgeId: neighborEdge.id });
                           predecessors.set(v, currentPreds);
                        }
                    }
                }
            }
            return { distances, predecessors };
        }

        function reconstructAllPaths(startNode, endNode, predecessorsMap) {
            const allPaths = [];
            function findPathsDFS(currentNodeId, currentPathNodes, currentPathEdges) {
                currentPathNodes.unshift(currentNodeId);
                if (currentNodeId === startNode) {
                    allPaths.push({ nodes: [...currentPathNodes], edges: [...currentPathEdges] });
                    currentPathNodes.shift(); 
                    return;
                }
                const predList = predecessorsMap.get(currentNodeId) || [];
                for (const pred of predList) {
                    if (!currentPathNodes.includes(pred.node)) { 
                        currentPathEdges.unshift(pred.edgeId);
                        findPathsDFS(pred.node, currentPathNodes, currentPathEdges);
                        currentPathEdges.shift(); 
                    }
                }
                currentPathNodes.shift(); 
            }
            findPathsDFS(endNode, [], []);
            return allPaths;
        }

        function displayPathSelectionUI(paths, totalDistance) {
            const pathSelectorContainer = document.getElementById('pathSelectorContainer');
            if (!pathSelectorContainer) return;
            pathSelectorContainer.innerHTML = ''; 

            if (paths.length <= 1) {
                pathSelectorContainer.style.display = 'none';
                return;
            }

            const label = document.createElement('label');
            label.htmlFor = 'pathSelector';
            label.textContent = `Se encontraron ${paths.length} rutas óptimas (costo ${totalDistance}). Seleccione una para visualizar:`;
            label.className = 'block text-sm font-medium mb-1 text-[var(--neutral-label)]';
            pathSelectorContainer.appendChild(label);

            const select = document.createElement('select');
            select.id = 'pathSelector';
            select.className = 'w-full'; 


            paths.forEach((path, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${index + 1}: ${path.nodes.join(' → ')}`;
                select.appendChild(option);
            });

            select.onchange = function() {
                const selectedIndex = parseInt(this.value);
                if (allCalculatedShortestPaths[selectedIndex]) {
                    highlightSpecificPath(allCalculatedShortestPaths[selectedIndex]);
                }
            };

            pathSelectorContainer.appendChild(select);
            pathSelectorContainer.style.display = 'block';
        }

        function highlightSpecificPath(pathObject) {
            clearVisualHighlightsOnly(); 

            const nodeUpdates = pathObject.nodes.map(nodeId => ({
                id: nodeId,
                color: { border: DIJKSTRA_PATH_NODE_BORDER_COLOR, background: DIJKSTRA_PATH_NODE_BG_COLOR }
            }));
            if (nodeUpdates.length > 0) visNodes.update(nodeUpdates);
            
            if (pathObject.edges && pathObject.edges.length > 0) {
                const edgeUpdates = pathObject.edges.map(edgeId => ({
                    id: edgeId,
                    color: { color: DIJKSTRA_PATH_EDGE_COLOR, highlight: DIJKSTRA_PATH_EDGE_COLOR, hover: DIJKSTRA_PATH_EDGE_COLOR }, 
                    width: 3.5 
                }));
                if (edgeUpdates.length > 0) visEdges.update(edgeUpdates);
                visuallyHighlightedPathEdges = [...pathObject.edges]; 
            } else {
                visuallyHighlightedPathEdges = [];
            }
        }


        function runDijkstra() {
            clearDijkstraPathVisuals(); 
            const startNodeId = startNodeSelect.value;
            const endNodeId = endNodeSelect.value;

            if (!startNodeId || !endNodeId) return showMessage('Seleccione nodo origen y destino.', 'error');
            
            if (startNodeId === endNodeId) {
                showMessage('Nodo origen y destino son el mismo. Distancia: 0.', 'info');
                visNodes.update({ id: startNodeId, color: { border: DIJKSTRA_PATH_NODE_BORDER_COLOR, background: DIJKSTRA_PATH_NODE_BG_COLOR } }); 
                return;
            }

            const { distances, predecessors } = dijkstraAlgorithm(startNodeId);
            const totalDistance = distances.get(endNodeId);

            if (totalDistance === Infinity) {
                showMessage(`No se encontró ruta entre "${startNodeId}" y "${endNodeId}" (considerando enlaces activos).`, 'error');
                return;
            }

            allCalculatedShortestPaths = reconstructAllPaths(startNodeId, endNodeId, predecessors); 
            console.log(`Todas las rutas (${allCalculatedShortestPaths.length}) más cortas encontradas desde ${startNodeId} hasta ${endNodeId}:`, allCalculatedShortestPaths);


            if (allCalculatedShortestPaths && allCalculatedShortestPaths.length > 0) {
                displayPathSelectionUI(allCalculatedShortestPaths, totalDistance);
                highlightSpecificPath(allCalculatedShortestPaths[0]); 

                let messageText = `Se encontró ${allCalculatedShortestPaths.length} ruta(s) más corta(s) con costo ${totalDistance}. `;
                if (allCalculatedShortestPaths.length > 1) {
                    messageText += `Seleccione una ruta para visualizarla. Mostrando: ${allCalculatedShortestPaths[0].nodes.join(' → ')}. (Revise la consola del desarrollador para ver todas).`;
                } else {
                    messageText += `Ruta: ${allCalculatedShortestPaths[0].nodes.join(' → ')}.`;
                }
                showMessage(messageText, 'success');
            } else {
                showMessage(`No se encontró ruta entre "${startNodeId}" y "${endNodeId}".`, 'error');
            }
        }
        
        function resetGraphVisualization() {
            clearDijkstraPathVisuals();
            visNodes.clear();
            visEdges.clear();
            updateAllSelectors(); 
            jsonInput.value = ''; 
            messageBox.textContent = ''; 
            messageBox.className = 'mb-6';
            network.setOptions({ physics: options.physics }); 
            showMessage('Simulación reiniciada.', 'info');
        }

        function loadGraphFromJson() {
            const jsonString = jsonInput.value;
            if (!jsonString.trim()) return showMessage('El campo JSON está vacío.', 'error');

            try {
                // Intentar pre-procesar el JSON para detectar errores comunes
                let cleanJsonString = jsonString
                    .replace(/[\u200B-\u200D\uFEFF]/g, '') // Eliminar caracteres invisibles
                    .replace(/,(\s*[}\]])/g, '$1') // Eliminar comas finales
                    .trim();

                let graphData;
                try {
                    graphData = JSON.parse(cleanJsonString);
                } catch (parseError) {
                    // Si falla, intentar con una limpieza más agresiva
                    cleanJsonString = cleanJsonString
                        .replace(/,\s*}/g, '}') // Eliminar comas antes de }
                        .replace(/,\s*]/g, ']') // Eliminar comas antes de ]
                        .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?\s*:/g, '"$2":') // Asegurar que las claves tengan comillas dobles
                        .replace(/:\s*(['"])?([a-zA-Z0-9_]+)(['"])?\s*(,|}|])/g, ':"$2"$4'); // Asegurar que los valores string tengan comillas dobles
                    
                    try {
                        graphData = JSON.parse(cleanJsonString);
                    } catch (finalError) {
                        throw new Error("JSON inválido. Por favor, verifica el formato y las comillas.");
                    }
                }
                
                if (typeof graphData !== 'object' || graphData === null) throw new Error("JSON debe ser un objeto.");
                if (!Array.isArray(graphData.nodes)) throw new Error("'nodes' debe ser un array.");
                if (graphData.edges && !Array.isArray(graphData.edges)) throw new Error("'edges' debe ser un array si existe.");

                resetGraphVisualization(); 

                const newNodes = [];
                for (const node of graphData.nodes) {
                    if (!node.id) throw new Error("Cada nodo JSON debe tener 'id'.");
                    const nodeProperties = { id: String(node.id), label: node.label || String(node.id) };
                    if (node.x !== undefined && node.y !== undefined) {
                        const x = parseInt(node.x), y = parseInt(node.y);
                        if (!isNaN(x) && !isNaN(y)) {
                            nodeProperties.x = x; nodeProperties.y = y; nodeProperties.physics = false; 
                        }
                    }
                    newNodes.push(nodeProperties);
                }
                if (newNodes.length > 0) visNodes.add(newNodes);

                if (graphData.edges) {
                    const newEdges = [];
                    let edgeCounter = 0; 
                    for (const edge of graphData.edges) {
                        if (!edge.from || !edge.to || edge.weight === undefined) throw new Error("Cada arista JSON debe tener 'from', 'to', y 'weight'.");
                        const weight = parseInt(edge.weight);
                        if (isNaN(weight) || weight < 0) throw new Error(`Peso inválido para ${edge.from}-${edge.to}.`);
                        const isActive = edge.active === undefined ? true : edge.active; 
                        let arrowsOption;
                        if (edge.directed === false) {
                            arrowsOption = { to: { enabled: false } };
                        } else {
                            arrowsOption = { to: { enabled: true, scaleFactor: 0.7 } };
                        }
                        newEdges.push({
                            id: edge.id || `jsonEdge-${edge.from}-${edge.to}-${edgeCounter++}`, 
                            from: String(edge.from), to: String(edge.to),
                            label: edge.label || String(weight), value: weight,
                            active: isActive, dashes: !isActive, 
                            arrows: arrowsOption,
                            color: isActive ? { color: OLIVINE_DEFAULT_EDGE_COLOR, highlight: OLIVINE_DEFAULT_EDGE_HIGHLIGHT_COLOR, hover: OLIVINE_DEFAULT_EDGE_HOVER_COLOR } : { color: OLIVINE_INACTIVE_EDGE_COLOR, highlight: OLIVINE_INACTIVE_EDGE_COLOR, hover: OLIVINE_INACTIVE_EDGE_COLOR }
                        });
                    }
                    if (newEdges.length > 0) visEdges.add(newEdges);
                }
                updateAllSelectors();
                network.fit({animation: {duration: 800, easingFunction: 'easeInOutQuad'}}); 
                showMessage('Topología cargada desde JSON.', 'success');
            } catch (error) {
                console.error('Error completo:', error);
                showMessage(`Error al cargar JSON: ${error.message}`, 'error');
            }
        }

        network.on("click", function (params) {
            clearDijkstraPathVisuals(); 
            if (params.edges.length > 0) { 
                const edgeId = params.edges[0];
                const edge = visEdges.get(edgeId);
                if (edge) {
                    const newActiveState = !edge.active;
                    visEdges.update({
                        id: edgeId, active: newActiveState, dashes: !newActiveState, 
                        color: newActiveState ? { color: OLIVINE_DEFAULT_EDGE_COLOR, highlight: OLIVINE_DEFAULT_EDGE_HIGHLIGHT_COLOR, hover: OLIVINE_DEFAULT_EDGE_HOVER_COLOR } : { color: OLIVINE_INACTIVE_EDGE_COLOR, highlight: OLIVINE_INACTIVE_EDGE_COLOR, hover: OLIVINE_INACTIVE_EDGE_COLOR }
                    });
                    showMessage(`Enlace ${edge.from}–${edge.to} ${newActiveState ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
                }
            }
        });

        function toggleFullscreen() {
            const networkContainer = document.getElementById('mynetwork');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const downloadBtn = document.getElementById('download-btn');
            const isFullscreen = networkContainer.classList.contains('fullscreen');
            
            if (!isFullscreen) {
                networkContainer.classList.add('fullscreen');
                fullscreenBtn.style.position = 'fixed';
                fullscreenBtn.style.top = '20px';
                fullscreenBtn.style.right = '20px';
                fullscreenBtn.style.zIndex = '10000';
                downloadBtn.style.position = 'fixed';
                downloadBtn.style.top = '20px';
                downloadBtn.style.right = '70px';
                downloadBtn.style.zIndex = '10000';
                network.redraw();
                network.fit();
            } else {
                networkContainer.classList.remove('fullscreen');
                fullscreenBtn.style.position = 'absolute';
                fullscreenBtn.style.top = '20px';
                fullscreenBtn.style.right = '20px';
                fullscreenBtn.style.zIndex = '10000';
                downloadBtn.style.position = 'absolute';
                downloadBtn.style.top = '20px';
                downloadBtn.style.right = '70px';
                downloadBtn.style.zIndex = '10000';
                network.redraw();
                network.fit();
            }
        }

        // Añadir soporte para la tecla Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const networkContainer = document.getElementById('mynetwork');
                if (networkContainer.classList.contains('fullscreen')) {
                    toggleFullscreen();
                }
            }
        });

        function downloadGraphImage() {
            // Obtener el canvas real de vis-network
            const canvas = document.querySelector('#mynetwork canvas');
            if (!canvas) {
                alert('No se pudo obtener la imagen del grafo.');
                return;
            }
            // Crear un enlace de descarga
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'grafo.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function copyJsonExample1() {
            const example1 = {
                "nodes": [
                    { "id": "A", "label": "Nodo A" },
                    { "id": "B", "label": "Nodo B" },
                    { "id": "C", "label": "Nodo C" },
                    { "id": "D", "label": "Nodo D" },
                    { "id": "E", "label": "Nodo E" },
                    { "id": "F", "label": "Nodo F" },
                    { "id": "G", "label": "Nodo G" },
                    { "id": "H", "label": "Nodo H" }
                ],
                "edges": [
                    { "from": "A", "to": "C", "weight": 1, "directed": false },
                    { "from": "A", "to": "B", "weight": 3, "directed": false },
                    { "from": "B", "to": "G", "weight": 5, "directed": false },
                    { "from": "B", "to": "D", "weight": 1, "directed": false },
                    { "from": "C", "to": "F", "weight": 5, "directed": false },
                    { "from": "C", "to": "D", "weight": 2, "directed": false },
                    { "from": "D", "to": "F", "weight": 2, "directed": false },
                    { "from": "D", "to": "E", "weight": 4, "directed": false },
                    { "from": "E", "to": "G", "weight": 2, "directed": false },
                    { "from": "E", "to": "H", "weight": 1, "directed": false },
                    { "from": "F", "to": "H", "weight": 3, "directed": false }
                ]
            };
            navigator.clipboard.writeText(JSON.stringify(example1, null, 2));
            const btn = document.getElementById('copy-json-example1');
            btn.textContent = '¡Copiado!';
            setTimeout(() => {
                btn.textContent = 'Copiar Ejemplo 1 - Grafo No Dirigido Simple';
            }, 1800);
        }

        function copyJsonExample2() {
            const example2 = {
                "nodes": [
                    {"id": "PC0", "label": "PC0"},
                    {"id": "PC1", "label": "PC1"},
                    {"id": "PC2", "label": "PC2"},
                    {"id": "PC3", "label": "PC3"},
                    {"id": "PC4", "label": "PC4"},
                    {"id": "PC5", "label": "PC5"},
                    {"id": "PC6", "label": "PC6"},
                    {"id": "PC7", "label": "PC7"},
                    {"id": "PC8", "label": "PC8"},
                    {"id": "PC9", "label": "PC9"},
                    {"id": "PC10", "label": "PC10"},
                    {"id": "PC11", "label": "PC11"},
                    {"id": "Laptop0", "label": "Laptop0"},
                    {"id": "Laptop1", "label": "Laptop1"},
                    {"id": "Server0", "label": "Server0"},
                    {"id": "Server1", "label": "Server1"},
                    {"id": "Server2", "label": "Server2"},
                    {"id": "AccessPoint0", "label": "AccessPoint0"},
                    {"id": "AccessPoint1", "label": "AccessPoint1"},
                    {"id": "Switch0", "label": "Switch0"},
                    {"id": "Switch1", "label": "Switch1"},
                    {"id": "Switch2", "label": "Switch2"},
                    {"id": "Switch3", "label": "Switch3"},
                    {"id": "Router0", "label": "Router0"},
                    {"id": "Router1", "label": "Router1"},
                    {"id": "Router2", "label": "Router2"}
                ],
                "edges": [
                    {"from": "PC0", "to": "Switch0", "weight": 1},
                    {"from": "PC1", "to": "Switch0", "weight": 1},
                    {"from": "PC2", "to": "Switch0", "weight": 1},
                    {"from": "PC3", "to": "Switch1", "weight": 1},
                    {"from": "PC4", "to": "Switch1", "weight": 1},
                    {"from": "PC5", "to": "Switch1", "weight": 1},
                    {"from": "PC6", "to": "Switch2", "weight": 1},
                    {"from": "PC7", "to": "Switch2", "weight": 1},
                    {"from": "PC8", "to": "Switch3", "weight": 1},
                    {"from": "PC9", "to": "Switch3", "weight": 1},
                    {"from": "PC10", "to": "Switch3", "weight": 1},
                    {"from": "PC11", "to": "Switch3", "weight": 1},
                    {"from": "Laptop0", "to": "AccessPoint0", "weight": 1},
                    {"from": "Laptop1", "to": "AccessPoint1", "weight": 1},
                    {"from": "Server0", "to": "Switch0", "weight": 1},
                    {"from": "Server1", "to": "Switch2", "weight": 1},
                    {"from": "Server2", "to": "Switch3", "weight": 1},
                    {"from": "AccessPoint0", "to": "Switch2", "weight": 1},
                    {"from": "AccessPoint1", "to": "Switch2", "weight": 1},
                    {"from": "Switch0", "to": "Router0", "weight": 2},
                    {"from": "Switch1", "to": "Router0", "weight": 2},
                    {"from": "Switch2", "to": "Router1", "weight": 2},
                    {"from": "Switch3", "to": "Router2", "weight": 2},
                    {"from": "Router0", "to": "Router1", "weight": 5},
                    {"from": "Router1", "to": "Router2", "weight": 5},
                    {"from": "Router2", "to": "Router0", "weight": 5}
                ]
            };
            const jsonStr = JSON.stringify(example2, null, 2);
            navigator.clipboard.writeText(jsonStr);
            const btn = document.getElementById('copy-json-example2');
            btn.textContent = '¡Copiado!';
            setTimeout(() => {
                btn.textContent = 'Copiar Ejemplo 2 - Red de Computadoras';
            }, 1800);
        }
    </script>
</body>
</html>
